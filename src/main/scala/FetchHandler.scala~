import akka.actor._
import akka.io._
import akka.util._
import java.net._
import com.typesafe.config._
import org.springframework.jdbc.core._
import scala.util._
import java.io._
import java.nio.file._
import java.util.Base64
import java.sql.ResultSet
import akka.event._

class FetchHandler extends TextQueryHandler("fetch (?<type>file|image|logo|article) (?<id>\\d+)".r) with JdbcHelpers with ArticleUtils {
	import Tcp._
	import Base64._
	import org.json4s._
	import org.json4s.JsonDSL._
	import org.json4s.jackson.JsonMethods._

	def apply(src: ActorRef, owner: ActorRef, db: JdbcTemplate, config: Config, log: LoggingAdapter, message: String, content: ByteString): Try[Next] = Try {
		val pattern(sort, id) = message
		val storePath = new File(config.getString("files.storePath")).toPath
		val next = sort match {
			case "article" ⇒
				get(db)("select * from news where id=?", id.toInt) { row: ResultSet ⇒
					val logo = get(db)("select * from files where sort='logo' and container=?", id.toInt) { rs ⇒
						val name = rs.getString("name")
						val path = storePath.resolve(name)
						val originalName = rs.getString("original_name")
						/*
						надо решить проблему с доступом к файлам, сохранённым ранее (в прежней версии портала). Проще всего воспользоваться тем, что объект не обязан ссылаться на реально существующий файл
						*/
						if (path.toFile.exists)
							new Attachment(name, originalName, Files.size(path), path.toFile)
						else
							new Attachment(name, originalName, 0, new File(name))
					}
					val article = ArticleRequest(Some(id.toInt), null, row.getBoolean("global"), row.getBoolean("local"), row.getBoolean("gallery"), row.getString("owner"), row.getString("owner_unit"), row.getString("title"), row.getString("date"), row.getString("annotation"), row.getString("text"), row.getString("uuid"), logo)
                                        article
				} match {
					case Some(article) ⇒
						src ! Write(ByteString("+%s\r\n" format compact(render(json(article, getFiles(db, id.toInt))))))
					case None ⇒ src ! Write(ByteString("-%s not found\r\n" format id))
				}
				Next("default", Map("buffer" -> content))
			case _ ⇒
				get(db)("select from files where sort=? and id=?", sort, id.toLong) { rs: ResultSet ⇒
					val name = rs.getString("name")
					storePath.resolve(name)
				} match {
					case Some(path) ⇒
						if (Files.exists(path)) {
							//context become waiting(content, path)
							src ! Write(ByteString("+%d\r\n" format Files.size(path)))
							Next("default", Map("buffer" -> content))
						} else {
							src ! Write(ByteString("-file not found\r\n"))
							Next("default", Map("buffer" -> content))
						}
					case None ⇒
						src ! Write(ByteString("-not found\r\n"))
						Next("default", Map("buffer" -> content))
				}
		}
                next
	}
}
