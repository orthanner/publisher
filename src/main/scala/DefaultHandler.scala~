import akka.actor._
import akka.io._
import akka.util._
import java.net._
import com.typesafe.config._
import org.springframework.jdbc.core._
import scala.util._
import scala.util.matching._
import java.util.regex._
import akka.pattern._
import scala.concurrent.duration._

object DefaultHandler {
	case class ProtocolMessage(message: String, content: ByteString)
	case class Loaded(pattern: Regex)
        type HandlerMap = Map[String ⇒ Boolean, ActorRef]
}

class DefaultHandler(src: ActorRef, client: InetSocketAddress, extensionClasses: List[String], config: Config, db: JdbcTemplate) extends Actor with ActorLogging {

	import DefaultHandler._
	import context.dispatcher

	val LINE_DELIMITER = Seq(13, 10)

	def receive = initializing(Map())

	implicit val timeout = Timeout(1 second)

	override def preStart(): Unit = {
		extensionClasses foreach { name ⇒
			context.actorOf(Props(Class.forName(name), src, config, db), name)
		}
	}

	def initializing(handlers: HandlerMap): Receive = {
		case Loaded(pattern: Regex) ⇒
			val newHandlers = handlers + ((pattern.pattern.asPredicate.test _, sender()))
			if (newHandlers.size == extensionClasses.size)
				context become handle(newHandlers, ByteString.empty)
			else
				context become initializing(newHandlers)
	}

	def handle(handlers: HandlerMap, data: ByteString): Receive = {
		case Tcp.Received(input) ⇒
			var content = data ++ input
			val pos = content.indexOfSlice(LINE_DELIMITER)
			if (pos == -1)
				context become handle(handlers, content)
			else {
				val message = content.slice(0, pos).utf8String.trim()
				content = content.drop(pos + 2)
				handlers find { case (regex, ref) ⇒ regex(message) } match {
					case Some(handler) ⇒ handler._2 ! ProtocolMessage(message, content)
					case None ⇒
						src ! Tcp.Write(ByteString("-Invalid command\r\n"))
						context.parent ! Next("default", Map("buffer" -> content))
				}
			}
                case next: Next => context.parent ! next
	}
}
